"" Personal VIM set up
" vim: foldmethod=marker foldlevel=999

" > Encoding ----------------------------------------------------------------{{{1

set encoding=utf-8
scriptencoding utf-8

" > Plugins -----------------------------------------------------------------{{{1

" Load our plugin bundles
call plug#begin('~/.vim/plugged')

" For each plugin I provide the path to the local documentation so I can quickly
" acess it using use `gf`.

"> Tim is the God of Vim: be sensible
"
"   ~/.vim/plugged/vim-sensible/README.markdown
"
Plug 'tpope/vim-sensible'


" Surrounding text objects with paired text;
"
"   ~/.vim/plugged/vim-surround/README.markdown
"   ~/.vim/plugged/vim-surround/doc/surround.txt
"
Plug 'tpope/vim-surround'


" Use [] prefix to trigger complementary pairs of operations :
"
"   ~/.vim/plugged/vim-unimpaired/README.markdown
"   ~/.vim/plugged/vim-unimpaired/doc/unimpaired.txt
"
Plug 'tpope/vim-unimpaired'


" Make repeat operations (`.`) work with plugin maps:
"
"   ~/.vim/plugged/vim-repeat/README.markdown
"
Plug 'tpope/vim-repeat'
 

" Comment stuff out with `gc`
"
"   ~/.vim/plugged/vim-commentary/README.markdown
"   ~/.vim/plugged/vim-commentary/doc/commentary.txt
"
Plug 'tpope/vim-commentary'


" Git done right 
"
"   ~/.vim/plugged/vim-fugitive/README.markdown
"   ~/.vim/plugged/vim-fugitive/doc/fugitive.txt
"
Plug 'tpope/vim-fugitive'


" Fugitive plugin to browse commit history 
"
"   ~/.vim/plugged/gv.vim/README.md
"
" Use :GV to open commit history browser
"
Plug 'junegunn/gv.vim'


" Show git "diff" markers in the gutter
"
"   ~/.vim/plugged/vim-gitgutter/README.mkd
"   ~/.vim/plugged/vim-gitgutter/doc/gitgutter.txt
"
" You can jump between hunks with `[c` and `]c`.
"
Plug 'airblade/vim-gitgutter'


" A fugitive extension to browse GitHub
"
"   ~/.vim/plugged/vim-rhubarb/README.markdown
"   ~/.vim/plugged/vim-rhubarb/doc/rhubarb.txt
"
" Use :Gbrowse to browse to the GitHub URL for the current buffer.
"
Plug 'tpope/vim-rhubarb'


" Vim scripting helpers
"
"   ~/.vim/plugged/vim-scriptease/README.markdown
"   ~/.vim/plugged/vim-scriptease/doc/scriptease.txt
"
" `g=` for evaluating expressions is useful for math
"
Plug 'tpope/vim-scriptease'


" Date and time arithmetic with C-a/C-x
"
"   ~/.vim/plugged/vim-speeddating/README.markdown
"   ~/.vim/plugged/vim-speeddating/doc/speeddating.txt
"
Plug 'tpope/vim-speeddating'


" File[system explorer
"
"   ~/.vim/plugged/nerdtree/README.markdown
"   ~/.vim/plugged/nerdtree/doc/NERDTree.txt
"
" Note: we always load so that Netrw hijacking works
"
Plug 'scrooloose/nerdtree'


" Extended "%" matching to "if", "else", "endif", etc, depending on language
"
"   ~/.vim/plugged/vim-matchit/README.md
"   ~/.vim/plugged/vim-matchit/doc/matchit.txt
"
Plug 'adelarsq/vim-matchit'


" Intelligent code and snippet completion
"
"   ~/.vim/plugged/coc.nvim/Readme.md
"   ~/.vim/plugged/coc.nvim/doc/coc.txt
"
" I'm mostly using this for Bash, Python, Javascript, and CSS/SASS
"
" Has its own Node based plugin system
"
"   * coc-css
"   * coc-html
"   * coc-json
"   * coc-markdownlint
"   * coc-python
"   * coc-snippets
"   * coc-tsserver  (javascript)
"   * coc-word      (google 10000 words)
"   * coc-yaml
"
Plug 'neoclide/coc.nvim', {'branch': 'release'}


" Asynchronous (on-the-fly) linting
"
"   ~/.vim/plugged/ale/README.md
"   ~/.vim/plugged/ale/doc/ale.txt
"
" Does this less intrusively than Coc.
"
" I'm mostly using this for Bash, Python, Javascript, and CSS/SASS
"  
Plug 'dense-analysis/ale'


" A collection of snippets files for various programming languages.
"
"   ~/.vim/plugged/vim-snippets/README.md
"
" Used by FZF and Coc
"
" XXX Audit these and replace with my-own
Plug 'honza/vim-snippets'


" Format code (on key mapping or save) using external programs.
"
"   ~/.vim/plugged/vim-autoformat/README.md
"
" This may be superseded by Coc.
" Currently seems more stable than Coc.
" Note: automatically removes trailing whitespace
" Can take a range to format only some part of the program
" XXX checkout remark for formating Markdown
"
Plug 'Chiel92/vim-autoformat'


" Editable quickfix list
"
" ~/.vim/plugged/vim-enmasse/README.md
" ~/.vim/plugged/vim-enmasse/doc/enmasse.txt
"
" Populate quickfix list then call :EnMasse to make a editable buffer linked to
" each of the quickfix items.
"
" Great combined with :grep to make global changes
"
Plug 'Olical/vim-enmasse'


" Open Zeal for online help
"
"   ~/.vim/plugged/zeavim.vim/README.md
"   ~/.vim/plugged/zeavim.vim/doc/zeavim.txt
"
" Calls external Zeal program
" Uses buffer filetype to guess docsets
Plug 'KabbAmine/zeavim.vim'


" A light and configurable statusline/tabline for Vim
"
"   ~/.vim/plugged/lightline.vim/README.md
"   ~/.vim/plugged/lightline.vim/doc/lightline.txt
"
Plug 'itchyny/lightline.vim'


" Git modification indicators in the status line
"
"   ~/.vim/plugged/lightline-gitdiff/README.md
"
" Shows counts for Added/Delete/Modified lines
"
Plug 'niklaas/lightline-gitdiff'


" Asynchronous compiler support
"
"   ~/.vim/plugged/vim-dispatch/README.markdown
"   ~/.vim/plugged/vim-dispatch/doc/dispatch.txt
"
Plug 'tpope/vim-dispatch'


" Running tests from current buffer
"
"   ~/.vim/plugged/vim-test/README.md
"   ~/.vim/plugged/vim-test/doc/test.txt
"
" Uses vim-dispatch
Plug 'janko-m/vim-test'


" Compiler for 'pytest' tests
"
"   ~/.vim/plugged/vim-compiler-pytest/README.md
"
" The secret sauce to get vim-test/dispatch working for pytest files
"
Plug 'tartansandal/vim-compiler-pytest'
 

" Indentation highlighting
"
"   ~/.vim/plugged/indentLine/README.md
"   ~/.vim/plugged/indentLine/doc/indentLine.txt
"
Plug 'Yggdroot/indentLine'


" Undo history visualization
"
"   ~/.vim/plugged/undotree/README.md
"   ~/.vim/plugged/undotree/doc/undotree.txt
"
" Useful for recovering a deleted/modified chunk from earlier in your session.
" Fills a gap for recovery outside of git commits.
"
Plug 'mbbill/undotree'


" A simple, easy-to-use Vim alignment plugin.
" 
"   ~/.vim/plugged/vim-easy-align/README.md
"   ~/.vim/plugged/vim-easy-align/EXAMPLES.md
"   ~/.vim/plugged/vim-easy-align/doc/easy_align.txt
"
" Good for managing tables in Markdown
"
" :EasyAlign
"
Plug 'junegunn/vim-easy-align'


" Simple checkbox support for Markdown lists
"
"   ~/.vim/plugged/vim-checkbox/README.markdown
"
"  `<leader>tt` to add or toggle a checkbox for the current item
"
Plug 'jkramer/vim-checkbox', { 'for': 'markdown' }


" Development version of the markdown runtime files
"
"   ~/.vim/plugged/vim-markdown/README.markdown
"
" Has some features that I like to track faster than the distribution
"
Plug 'tpope/vim-markdown'


" Fuzzy Finding of all things
"
"   ~/.vim/plugged/fzf.vim/README.md
"   ~/.vim/plugged/fzf.vim/doc/fzf-vim.txt
"
" Does not map well to my ususal development patterns
" Some of the functions are really cool though.
"
Plug 'junegunn/fzf.vim'


" Darcula colorscheme that looks just like PyCharm
"
"   ~/.vim/plugged/darcula/README.md
"
" Compared with the others
"
"   https://github.com/blueshirts/darcula
"
"       Most popular, but not a not a good approximation
"
"   https://github.com/joshglendenning/vim-darcula-colors' 
"
"       This is a better approximation.
"       Could be the basis for a base16 version
"
Plug 'doums/darcula'


" Tools to create your own text objects
"
"   ~/.vim/plugged/vim-textobj-user/README.md
"   ~/.vim/plugged/vim-textobj-user/doc/textobj-user.txt
"
" Requried by vim-textobj-uri
"
Plug 'kana/vim-textobj-user'


" URI text objects
"
"   ~/.vim/plugged/vim-textobj-uri/README.md
"
" Gives you a `u` text object for operating on URIs 
"
Plug 'jceb/vim-textobj-uri'


" Open browser/search on url/word under cursor
"
"   ~/.vim/plugged/open-browser.vim/README.md
"   ~/.vim/plugged/open-browser.vim/doc/openbrowser.txt
"
" More reliable than the built in `gx` command from Netrw.
"
Plug 'tyru/open-browser.vim'

" Explore Most Recently Used (MRU) files
"
"   ~/.vim/plugged/mru/README
"   ~/.vim/plugged/mru/doc/mru.txt
"
" Part of my Switcher utility
"
Plug 'yegappan/mru'


" Explore currently loaded buffers
"
"   ~/.vim/plugged/bufexplorer/README.md
"   ~/.vim/plugged/bufexplorer/doc/bufexplorer.txt
"
" Part of my Switcher utility
"
Plug 'jlanzarotta/bufexplorer'


" Base-16 colorschemes (all of them plus my own)
"
"   ~/.vim/plugged/base16-vim/README.md
"
" XXX Lots of schemes = big hit on load time. 
" I Just want one of the themes.
" Want to be able to toggle between 'base16-dirtysea' and 'darclua'
"
" Plug 'tartansandal/base16-vim'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Still experimenting with these
"
" Plug 'Shougo/denite.nvim'
" Plug 'roxma/nvim-yarp'
" Plug 'roxma/vim-hug-neovim-rpc'

" Plug 'francoiscabrol/ranger.vim'
" let g:ranger_map_keys=0
" >> Ranger only works in terminal

" A Debugger built into Vim8 EXPERIMENTAL
"
"   ~/.vim/plugged/vimspector/README.md
"   ~/.vim/plugged/vimspector/docs/README.local
"   ~/.vim/plugged/vimspector/docs/configuration.md
"
" Plug 'puremourning/vimspector'
" let g:vimspector_enable_mappings = 'HUMAN'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""" Some plugins I no longer need/use

" Plug 'alfredodeza/pytest.vim'
" >> Interferes with vim-test and the :PyTest command

" Plug 'ycm-core/YouCompleteMe'
" >> Superseded by Coc and Ale
"
" Plug 'Glench/Vim-Jinja2-Syntax'
" >> have not used Jinja2 in a while
"
" Plug 'jacquesbh/vim-showmarks'
" >> I just dont use marks enough for this to be useful
"
" Plug 'ntpeters/vim-better-whitespace'
" >> Superseded by auto-formaters and auto-fixers

" Plug 'keith/investigate.vim'
" >> tend to use Zeal instead

" Plug 'vim-scripts/Decho'
" >> temp for debugging netrw

call plug#end()

" > General Settings -------------------------------------------------------{{{1

"------------------------------------------
" Formating and Motion:
"------------------------------------------

"
" Limit line length to 80-88 chars.
" Black has some rationale for extending beyound 80
"
set textwidth=80         "Wrap at this column
set colorcolumn=+1       "Columns to highlight after textwidth

"
" Indent 4 spaces - a consistent and common convention
"
set tabstop=4            "Indentation levels every four columns
set shiftwidth=4         "Indent/outdent by four columns
set expandtab            "Convert all tabs typed to spaces
set smartindent          "Smart autoindenting when starting a new line
set shiftround           "Indent/outdent to nearest tabstop

"> same as sensible
set autoindent                   "Preserve current indent on new lines
set backspace=indent,eol,start   "Make backspaces delete sensibly
set smarttab

"> same as sensible
set nrformats-=octal    " Do not recognize octal numbers for Ctrl-A and Ctrl-X

"
" Relative line numbers to encourage me to use line oriented motions more.
"
set relativenumber       " Display relative line numbers

"
" Automatice formating. The default is tcq. See 'help fo-table'
"
set formatoptions+=t    " Auto-wrap text using textwidth
set formatoptions+=c    " Auto-wrap comment text using comment leader
set formatoptions+=q    " Allow formatting of comments with "gq"
set formatoptions+=o    " Insert the current comment leader after hitting 'o'
" set formatoptions+=a    " Autoformat while editing
set formatoptions+=n    " Recognize numbered lists
set formatoptions+=l    " Long lines are not broken in insert mode
set formatoptions+=1    " Don't break a line after a one-letter word.
set formatoptions+=j    " Remove stray comment leaders when reformating
set formatoptions+=p    " Don't break lines at single spaces that follow periods.
set joinspaces          " Insert 2 spaces after '.' with the join command
set cpoptions+=J        " Two spaces after a '.' defines a sentence

" Use both system clipboard (+) and selection (*) for yank and put
set clipboard^=unnamed,unnamedplus


" Allow virtual editing in visual block mode so we can form rectangles
set virtualedit=block

set whichwrap+=<>[]     " Left arrow traverses the begining of the line
set matchpairs+=<:>     " Allow % to bounce between angles too

" May need this for paste in a terminal
" NB dont set paste in vimrc since that will override you expandtab setting
set pastetoggle=<F2>

set spelllang=en_au
set printoptions=paper:A4,formfeed:y

" (sensible)
set ttimeout            " Time out for key codes
set ttimeoutlen=100     " Wait up to 100ms after Esc for special key


"------------------------------------------
" Completion:
"------------------------------------------

set complete -=i " dont search included files
set wildmenu     " (sensible)

" ignore files we will never want to edit
set wildignore+=*.o,*.exe,*~,CVS,.svn,*.gz,*.zip,*.bz2,*.tgz
set wildignore+=*.dsc,*.rpm,*.deb,*.xpm,*.png

" set omnifunc=syntaxcomplete#Complete

" list all matches and complete till longest common strings
" This conflicts with statusline display
" set wildmode=list:longest

" Autocomplete with dictionary words when spell check is on
" set complete+=kspell

"------------------------------------------
"" Display:
"------------------------------------------

" The following helps with spurious "Press Enter" requests
set laststatus=2    " always display status bar (sensible)
set cmdheight=2     " 2 lines for command buffer
set showcmd         " display incomplete commands

" (sensible)
set scrolloff=1         " always show 1 lines of context when scrolling
set sidescrolloff=5     " keep at least 5 columns of context to either side

" Specify which characters to use for 'listing'. (not sensible)
set listchars=tab:→\ ,trail:·,nbsp:¤,precedes:«,extends:»,eol:↲
"set list     " turn on display of listchars
"set nolist   " turn off display of listchars
	    
set foldlevelstart=99

" (sensible): 
set incsearch

" clear search highlighting on startup
nohlsearch

" Dont highlight strings in comments since they are often irrelevant
if exists('c_comment_strings')
    unlet c_comment_strings
endif

if has('mouse')
    set mousehide
    set mousemodel=popup_setpos
    set mouse=a
endif

" FIXME need to sort out my colorscheme loading
"
" For some weird reason this does not load in terminal vim

" let g:base16_shell_path="~/.config/base16-shell/scripts"

" Load the current shell colorscheme
" if filereadable(expand("~/.vimrc_background"))
"   let base16colorspace=256
"   source ~/.vimrc_background

"   " remove some boldings
"   hi Statement gui=None

" endif

" Alternatively just use darcula
colorscheme darcula
hi Cursor guifg=#2B2B2B guibg=#BBBBBB
hi ColorColumn guifg=#808080 guibg=#313335

" be good if we could toggle this
" colorscheme base16-dirtysea
" hi Statement gui=None

if &term == 'screen' || &term =~? 'xterm.*'"
  " Reset the cursor if running in terminal (a no-op in gui)
  let &t_SI = "\e[6 q"
  let &t_EI = "\e[2 q"

  " Make termguicolors work with tmux/screen (a no-op for the gui)
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"

  " Fixes glitch in colors when using vim with tmux
  set t_Co=256

  set termguicolors  " use the full 24bit colorspace
endif

" -----------------
" Files:
" -----------------

set path+=**            " search for files recursively
set autoread            " re-read open files when changed outside Vim
set autowrite           " write file whenever buffer becomes hidden
set hidden              " hide buffers when they are abandoned
set browsedir=current   " which directory to use for the file browser
set fileformat=unix

" keep backups under ~/tmp
" set backup          " keep a backup file
" set backupcopy=yes  " copy the original even if a link
" set backupdir=~/tmp/backup,~/,/tmp

set undodir=~/tmp/undo,~/,/tmp
set undofile          " keep a undo file
set undolevels=100    " maximum number of changes that can be undone
set undoreload=1000   " maximum number lines to save for undo on a buffer reloada

set cryptmethod=blowfish  " use stronger encryption by default

set noswapfile  " swapfiles an annoyance since I save often

" write readonly file as root
" this is hanging, don't know why
" command! W :execute ':silent w !sudo tee % > /dev/null' | :edit!

" use rg for gr[ep]
set grepprg=rg\ --vimgrep\ --max-columns\ 160\ --max-filesize\ 1M
set grepformat^=%f:%l:%c:%m

" Speed up diff by ignoring localisations
let g:diff_translations=0

" Always use vertical diffs
set diffopt+=vertical

" If we are running vim-tiny, none of the sexy plugins or filetype detections
" will work anyway, so skip the rest of the file.
if !has('autocmd')
    finish
endif

"------------------------------------------
" File Types:
"------------------------------------------

" Enable file type detection.
" Also load indent files, to automatically do language-dependent indenting
" All filetype detections commands go in .vim/ftdetect/
" All filetype specific settings go in .vim/ftplugin/
" All modifications to plugins go under .vim/after/{ftplugin,ftdetect}
filetype plugin indent on

let g:xml_use_xhtml=1
let g:xml_syntax_folding=1

" I find concealing confusing
let g:vim_json_conceal = 0
let g:markdown_syntax_conceal=0

" markdown
let g:markdown_folding=1
let g:markdown_minlines = 100
let g:markdown_fenced_languages = ['bash', 'python', 'css', 'js=javascript']

" See ft_sql.vim
let g:sql_type_default='mysql'

" want this abbreviation, but just for python mode
" ab ip import ipdb; ipdb.set_trace()
" of perhaps just a <leader> keymap

" XXX Should use ultisnips for this
function! InsertBreakPoint()
    if &filetype ==? 'python'
        normal! Oimport ipdb; ipdb.set_trace()  # noqa XXX
    endif
endfunction
noremap <silent> <leader>b :call InsertBreakPoint()<CR>

"Insert a pudb breakpoint below or above current line
" nnoremap <leader>b oimport pudb.b<Esc>
" nnoremap <leader>B Oimport pudb.b<Esc>

"Insert a ipdb breakpoint below or above current line
nnoremap <leader>b oimport ipdb; ipdb.set_trace()  # BREAKPOINT # noqa: E702<Esc>
nnoremap <leader>B Oimport ipdb; ipdb.set_trace()  # BREAKPOINT # noqa: E702<Esc>

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
" Revert with: ":delcommand DiffOrig".
if !exists(':DiffOrig')
    command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
                \ | wincmd p | diffthis
endif

" > Plugin Settings ---------------------------------------------------------{{{1
" >> Misc -------------------------------------------------------------------{{{2

" undotree
let g:undotree_ShortIndicators=1

" lightline
set noshowmode
let g:lightline={
            \   'active': {
            \     'left': [
            \        [ 'mode', 'paste' ],
            \        [ 'gitbranch', 'readonly', 'filename', 'modified' ],
            \        [ 'gitdiff' ]
            \     ],
            \     'right': [
            \        [ 'lineinfo' ], [ 'percent' ],
            \        [ 'filetype' ]
            \     ]
            \   },
            \   'inactive': {
            \     'left': [
            \        [ 'filename', 'gitversion' ]
            \     ]
            \   },
            \   'component_function': {
            \     'cocstatus': 'coc#status',
            \     'gitbranch': 'fugitive#head',
            \   },
            \   'component_expand': {
            \     'gitdiff': 'lightline#gitdiff#get',
            \   },
            \   'component_type': {
            \     'gitdiff': 'middle',
            \   },
            \}
" let g:lightline['colorscheme'] = 'wombat'
let g:lightline['colorscheme'] = 'darculaOriginal'

let g:zv_zeal_executable=expand('~/bin/zeal')
let g:zv_docsets_dir=expand('~/.local/share/Zeal/Zeal/docsets/')


" >> Vim-Test --------------------------------------------------------------{{{2
" vim-test
"   ~/.vim/plugged/vim-dispatch/doc/dispatch.txt
"   ~/.vim/plugged/vim-test/README.md
"   ~/.vim/plugged/vim-test/doc/test.txt

let test#python#runner = 'pytest'

" These should include the options for your compiler
" We exclude the coverage report which is skipped by the quickfix listing
" ('suite' or 'file') and makes no sense for a single test ('nearest').
" Also add the `--vv` so we see breakdown of an assertion failure.
let test#python#pytest#options = '--tb=short -q --no-cov -vv'

" For 'suite' and 'file', we process the errors with a compiler and present the
" result in a quickfix list so we can esily navigate to errors.
" For 'nearest', we show the full details for the error.
" This facillitates the following process:
"   1. Run a :TestFile or :TestSuite
"   2. Use the quickfix to jump to an "interesting" test that is breaking
"   3. Run :TestNearest to rerun just that test, but show the full details.
let test#strategy = {
  \ 'suite':   'dispatch',
  \ 'file':    'dispatch',
  \ 'nearest': 'vimterminal', 
\}

" Use F1 to enter Terminal Normal Mode.  For some reason <C-W>N just gives me
" a new window.  Only use this for testig the following augroup. 
tnoremap <F1> <C-W>N

augroup terminal
    autocmd!
    " The `relativenumber` and `signcolumn` options shift the content of
    " terminal windows 6 columns to the right. This causes terminal content to
    " wrap in Normal Mode, which does not look good in PyTest output, so we turn
    " these off.  We alos hide the `colorcolumn` which makes no sense in
    " terminal.
    autocmd TerminalOpen,TerminalWinOpen * 
            \  if &buftype ==# 'terminal' 
            \   | setlocal norelativenumber 
            \   | setlocal signcolumn=no
            \   | setlocal colorcolumn=0
            \| endif
augroup END

" >> BufExplorer:-----------------------------------------------------------{{{2

" Part of my Switcher utility. 
"
" Settings try to make this behave similarly to the `MRU`.
"
let g:bufExplorerDefaultHelp=0       " Dont show help by default.
let g:bufExplorerDetailedHelp=0      " Do not show detailed help.
let g:bufExplorerFindActive=1        " Go to active window on select.
let g:bufExplorerReverseSort=0       " Do not sort in reverse order.
let g:bufExplorerShowDirectories=0   " Don't show directories.
let g:bufExplorerShowNoName=0        " Do not show "No Name" buffers.
let g:bufExplorerShowUnlisted=0      " Do not show unlisted buffers.
let g:bufExplorerShowTabBuffer=0     " Don't restrict to this tabs buffers.
let g:bufExplorerShowRelativePath=1  " Show relative paths.
let g:bufExplorerSortBy='mru'        " Sort by most recently used.
let g:bufExplorerSplitBelow=1        " Split new window below current.
let g:bufExplorerSplitOutPathName=0  " Split the path and file name.
let g:bufExplorerSplitHorzSize=15    " New window is 15 rows high (same as MRU).

" Disable default <leader> mappings.
let g:bufExplorerDisableDefaultKeyMapping=1  

" Default mappings for the bufexplore window
"
" <F1>          Toggle help information.
" <enter>       Opens the buffer under the cursor into the current window.
" d             |:delete| the buffer under the cursor from the list.
" D             |:wipeout| the buffer under the cursor from the list.
" q             Exit/Close bufexplorer.
" r             Reverses the order the buffers are listed in.
" R             Toggles relative path/absolute path.
" s             Cycle thru how the buffers are listed
" S             Cycle thru how the buffers are listed, in reverse order.
" T             Toggles to show only buffers for this tab or not.
" u             Toggles the showing of "unlisted" buffers.
"
" >> MRU:-------------------------------------------------------------------{{{2

" Part of my Switcher utility. 
"
" Settings try to make this behave similarly to the `buffexplorer`.
"
let MRU_File = expand('~/.vim_mru_files')
let MRU_Exclude_Files = 'COMMIT_EDITMSG\|^/tmp/.*\|^/var/tmp/.*'
let MRU_Max_Entries = 100
let MRU_Use_Current_Window = 0 " Always use a new window
let MRU_Window_Height = 15     " Same height as the bufexplorer
let MRU_Auto_Close = 1         " Close window after selecting
let MRU_Add_Menu = 0           " Dont bother with the menu items

" Dont split out path and filename
let MRU_Filename_Format =
\   {'formatter':'v:val', 'parser':'.*', 'syntax': '[^/\\]\+$'}

" TODO: 
" 1. Add a mapping to delete entries from the MRU list.
" 2. Port relative filename feature from buffexplorer
"
" The MRU buffer uses the 'mru file type. You can use this file type to add
" custom auto commands, syntax highlighting, etc.

" Default mappings:
"   <Enter>         Open file
"   <Shift-Enter>   Open in new window
"   o               Open in new window
"   v               Open in read-only mode
"   t               Open in a new tab
"   u               Update file list
"   q               Close window

highlight link MRUFileName String

" >> Denite -----------------------------------------------------------------{{{2
"
"" Define mappings
"autocmd FileType denite call s:denite_my_settings()
"function! s:denite_my_settings() abort
"    nnoremap <silent><buffer><expr> <CR>
"    \ denite#do_map('do_action')
"    nnoremap <silent><buffer><expr> d
"    \ denite#do_map('do_action', 'delete')
"    nnoremap <silent><buffer><expr> p
"    \ denite#do_map('do_action', 'preview')
"    nnoremap <silent><buffer><expr> q
"    \ denite#do_map('quit')
"    nnoremap <silent><buffer><expr> i
"    \ denite#do_map('open_filter_buffer')
"    nnoremap <silent><buffer><expr> <Space>
"    \ denite#do_map('toggle_select').'j'
"endfunction
""
"" Ripgrep command on grep source
"call denite#custom#var('grep', 'command', ['rg'])
"call denite#custom#var('grep', 'default_opts',
"        \ ['-i', '--vimgrep', '--no-heading'])
"call denite#custom#var('grep', 'recursive_opts', [])
"call denite#custom#var('grep', 'pattern_opt', ['--regexp'])
"call denite#custom#var('grep', 'separator', ['--'])
"call denite#custom#var('grep', 'final_opts', [])

" >> FZF --------------------------------------------------------------------{{{2

let g:fzf_colors = {
            \ 'fg':      ['fg', 'Normal'],
            \ 'bg':      ['bg', 'Normal'],
            \ 'hl':      ['fg', 'Function'],
            \ 'fg+':     ['fg', 'Normal'],
            \ 'bg+':     ['bg', 'Normal'],
            \ 'gutter':  ['bg', 'Normal'],
            \ 'hl+':     ['fg', 'DiffText'],
            \ 'info':    ['fg', 'PreProc'],
            \ 'prompt':  ['fg', 'DiffChange'],
            \ 'border':  ['fg', 'Cursor'],
            \ 'pointer': ['fg', 'Normal'],
            \ 'marker':  ['fg', 'Keyword'],
            \ 'header':  ['fg', 'Structure'],
            \ 'spinner': ['fg', 'Structure'],
            \}

" TODO: make a PR for fzf README offering this explanation
" The above color setting is tricky.
"
" The arguments to each color group are a search spec:
"
"    item: [ layer, group+ ... ]
"
"   - item: the element of the display to color
"       - fg  / bg  / hl    : non-selected lines
"       - fg+ / bg+ / hl+   : selected lines
"       - hl  / hl+         : strings matching the search
"       - gutter            : the backgound of the frst 2 columns
"       - pointer / marker  : '>' indicator in the gutter
"       - border            : border around terminal window
"       - header            : line containing the current file
"       - info              : match counters
"       - spinner           : char at column 1 before the match counters
"       - prompt            : prompt before input strings
"
"   - layer: extract the color from this layer (fg/bg)
"
"   - groups+: a list of highlight groups to search
"
" For the 'fg+', 'bg+', 'hl+', 'prompt', 'pointer', and 'marker' items, the
" color only matches if the highlight group has term=bold set. If not it falls
" back to the defaults.  This last bit can cause a lot of confusion.

let g:fzf_history_dir = '~/.local/share/fzf-history'
let g:fzf_buffers_jump = 1
let g:fzf_files_options = ''

augroup fzf
    " Hide ruler when FZF window is active
    autocmd!
    autocmd FileType fzf set laststatus=0 noshowmode noruler
                \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler
augroup end

" >> NERDTree ---------------------------------------------------------------{{{2

let NERDTreeCaseSensitiveSort=1

"let NERDTreeChDirMode=0 " cwd never changed by NERD
"let NERDTreeChDirMode=1 " cwd changed on NERD load
let NERDTreeChDirMode=2  " cwd follows root

let NERDTreeHijackNetrw=1
let NERDTreeShowBookmarks=0
let NERDTreeIgnore=[
    \   '\~$',
    \   '\.\(desktop\|pyc\|pdf\|odt\|odg\|doc\|xls\|png\|ai\|jpg\)$',
    \   '__pycache__'
    \]
let NERDTreeQuitOnOpen=1
let NERDTreeAutoCenter=1
let NERDTreeWinSize=31
let NERDTreeWinSizeMax=93
" Sort directories first
let NERDTreeSortOrder=['\/$', '*', '\.swp$',  '\.bak$', '\~$']

" Putting this on the right means the content in source window (which is left
" aligned) move less when toggle the browser
let NERDTreeWinPos='right'
let NERDTreeHighlightCursorline=1
let NERDTreeHijackNetrw=1

" >> Netrw ------------------------------------------------------------------{{{2

" XXX Seeing way to many bugs and errors with this. Dont think its maintained
" much anymore.

" tpope's suggestions
" nnoremap <leader>e :Explore<CR>
let g:netrw_banner=0

let g:netrw_sizestyle='b' " human readable sizes

"" Default listing style
" let g:netrw_liststyle=0     " thin
let g:netrw_liststyle=1     " long
" let g:netrw_liststyle=2     " wide
" let g:netrw_liststyle=3       " tree

let g:netrw_browse_split=0  " current window
" let g:netrw_browse_split=1  " new horizontal split
" let g:netrw_browse_split=2  " new vertical split
" let g:netrw_browse_split=3  " new tab
" let g:netrw_browse_split=4    " open previous window

" let g:netrw_preview=0         " preview in horizontal split window
" let g:netrw_preview=1         " preview in vertical split window

" let g:netrw_altv=0            " default to left splitting
" let g:netrw_altv=1          " default to right splitting
" let g:netrw_alto=0            " default to splitting above
let g:netrw_alto=1          " default to splitting below
let g:netrw_winsize=25        " % of window width/height to use
" let g:netrw_keepdir=0         " current dir tracks browsing dir
let g:netrw_keepdir=1         " current dir does not track browsing dir

"" Default hiding
" let g:netrw_hide=0          " show all
let g:netrw_hide=1            " show not-hidden files
" let g:netrw_hide=2          " show hidden files only
let g:netrw_list_hide='\(^\|\s\s\)\zs\.\S\+'

" Listing Speed
" let g:netrw_fastbrowse=0      " slow:  always obtains directory listings
let g:netrw_fastbrowse=1        " medium: re-use listings only when remote browsing
" let g:netrw_fastbrowse=2      " fast: only obtains new directory listings

" FIXME this does not work for me
let g:netrw_use_tab=1           " ctrl-tab to shrink/expand Lexplorer window

let g:netrw_special_syntax=1    " highlight special (binary) files

" " XXX Dont set this! xdg-open needs to be run in the background. Had to patch
" that separately
" let g:netrw_browsex_viewer="xdg-open"
" let g:netrw_suppress_gx_mesg=1

" >> Ale --------------------------------------------------------------------{{{2

"" These get merged with the global list
"" let g:ale_lint_on_text_changed=0
"" let g:ale_lint_on_insert_leave=1

let g:ale_maximum_file_size=50000

" A note on text linters:
"
"   * languagetool is too slow and does not handle markdown well
"   * write-good gave too many false positives
"   * textlint rouseau gave too many false positives
"   * proselint seemed to be the best middle-ground

" let g:ale_python_flake8_use_global = 1
" let g:ale_python_flake8_executable = '/usr/bin/flake8'

" > Linting
let g:ale_linters={
            \ 'python': ['flake8'],
            \ 'markdown': ['mdl'],
            \ }
let g:ale_markdown_mdl_options='--style ~/.mdl-style.rb'

" > Fixing
let g:ale_fixers={
            \ 'python':   ['remove_trailing_lines', 'trim_whitespace'],
            \ 'markdown': ['remove_trailing_lines', 'trim_whitespace']
            \ }
let g:ale_fix_on_save=1

" > Display
let g:ale_sign_error='✗'
let g:ale_sign_style_error='✗'
let g:ale_sign_warning='!'
let g:ale_sign_style_warning='!'

" >> Coc -------------------------------------------------------------------{{{2

" Some servers have issues with backup files, see #649
"
" NOTE: Since I write backups outside of the project root, tsserver will not see
" this as a project change and will not trigger a recompile.
"
" set nobackup
" set nowritebackup

" You will have bad experience for diagnostic messages when it's default 4000.
" NOTE: Since I'm using ALE for diagnostics, this is not relevant 
" set updatetime=300

" don't give |ins-completion-menu| messages.
set shortmess+=c

" always show signcolumns ()
set signcolumn=yes

" Use tab for trigger completion with characters ahead and navigate.
" Use command ':verbose imap <tab>' to make sure tab is not mapped by other
" plugin.
inoremap <silent><expr> <TAB>
            \ pumvisible() ? "\<C-n>" :
            \ <SID>check_back_space() ? "\<TAB>" :
            \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-space> to trigger completion.
inoremap <silent><expr> <c-space> coc#refresh()

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
" Coc only does snippet and additional edit on confirm.
inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
" Or use `complete_info` if your vim support it, like:
" inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"

" Use `[g` and `]g` to navigate diagnostics
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
    if (index(['vim','help'], &filetype) >= 0)
        execute 'h '.expand('<cword>')
    else
        call CocAction('doHover')
    endif
endfunction

" Highlight symbol under cursor on CursorHold
" XXX Does not seem to work for me
autocmd CursorHold * silent call CocActionAsync('highlight')

" Remap for rename current word
nmap <leader>rn <Plug>(coc-rename)

" Remap for format selected region
xmap <leader>rf  <Plug>(coc-format-selected)<CR>
nmap <leader>rf  <Plug>(coc-format-selected)<CR>

augroup coc
    autocmd!
    " Setup formatexpr specified filetype(s).
    autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
    " Update signature help on jump placeholder
    autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" " Remap for do codeAction of selected region, ex: `<leader>aap` for current paragraph
" xmap <leader>a  <Plug>(coc-codeaction-selected)
" nmap <leader>a  <Plug>(coc-codeaction-selected)

" " Remap for do codeAction of current line
" nmap <leader>ac  <Plug>(coc-codeaction)
" " Fix autofix problem of current line
" nmap <leader>qf  <Plug>(coc-fix-current)

" Create mappings for function text object, requires document symbols feature of languageserver.
xmap if <Plug>(coc-funcobj-i)
xmap af <Plug>(coc-funcobj-a)
omap if <Plug>(coc-funcobj-i)
omap af <Plug>(coc-funcobj-a)

" " Use <TAB> for select selections ranges, needs server support, like: coc-tsserver, coc-python
" nmap <silent> <TAB> <Plug>(coc-range-select)
" xmap <silent> <TAB> <Plug>(coc-range-select)

" Use `:Format` to format current buffer
command! -nargs=0 Format :call CocAction('format')

" Use `:Fold` to fold current buffer
command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" use `:OR` for organize import of current buffer
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

" use `:Run` run the current buffer
command! -nargs=0 Run  :call     CocAction('runCommand', 'python.execInTerminal')

" Add status line support, for integration with other plugin, checkout `:h coc-status`
"set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

">>>> Using CocList
" Show all diagnostics
nnoremap <silent> <space>a  :<C-u>CocList diagnostics<cr>
" Manage extensions
nnoremap <silent> <space>e  :<C-u>CocList extensions<cr>
" Show commands
nnoremap <silent> <space>c  :<C-u>CocList commands<cr>
" Find symbol of current document
nnoremap <silent> <space>o  :<C-u>CocList outline<cr>
" Search workspace symbols
nnoremap <silent> <space>s  :<C-u>CocList -I symbols<cr>
" Do default action for next item.
nnoremap <silent> <space>j  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent> <space>k  :<C-u>CocPrev<CR>
" Resume latest coc list
nnoremap <silent> <space>p  :<C-u>CocListResume<CR>

">>>> Using coc-snippets

" Use <C-l> for trigger snippet expand.
imap <C-l> <Plug>(coc-snippets-expand)

" Use <C-j> for select text for visual placeholder of snippet.
vmap <C-j> <Plug>(coc-snippets-select)

" Use <C-j> for jump to next placeholder, it's default of coc.nvim
let g:coc_snippet_next = '<c-j>'

" Use <C-k> for jump to previous placeholder, it's default of coc.nvim
let g:coc_snippet_prev = '<c-k>'

">>>> Using coc-lightline
"autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()

"" Default cursor settings
set guicursor=n-v-c:block-Cursor/lCursor
set guicursor+=ve:ver35-Cursor
set guicursor+=o:hor50-Cursor
set guicursor+=i-ci:ver25-Cursor/lCursor
set guicursor+=r-cr:hor20-Cursor/lCursor
set guicursor+=sm:block-Cursor-blinkwait175-blinkoff150-blinkon175

" hi CocErrorSign   ctermfg=Red     guifg=#840000  " base0E
" hi CocWarningSign ctermfg=Brown   guifg=#755B00  " base0C
" hi CocInfoSign    ctermfg=Yellow  guifg=#730073  " base0B
" hi CocHintSign    ctermfg=Blue    guifg=#000090  " base08
" hi CocCodeLens    ctermfg=Gray    guifg=#006565  " base09

" > Key Mapping ------------------------------------------------------------{{{1

" replace netrw's gx with somethig that works
let g:netrw_nogx = 1 " disable netrw's gx mapping.
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

" Windows
" noremap <Tab> <c-w>w
" noremap <Shift-Tab> <c-w>W

" Should really just use C-W C-W: I rarely have more than 3 windows open.
" nnoremap <S-Up>    <c-w>k
" nnoremap <S-Down>  <c-w>j
" nnoremap <S-Left>  <c-w>h
" nnoremap <S-Right> <c-w>l

" Tabs
" Use control + arrow key to move between tabs
" (same as for gnome terminal tabs)
noremap <C-Right>       :tabnext<CR>
noremap <C-Left>        :tabprevious<CR>


" Switcher -----------------------------------------------------------------{{{2
function! MyCycleNextLine()
    " Proceed to next line, or back to the top
    if getline('.') == getline('$')
        :1
    else
        :+
    endif
endfunction

function! Switcher()
    silent! NERDTreeClose
    if len(getbufinfo({'buflisted':1})) > 1
        " Buff explorer 
        BufExplorerHorizontalSplit
        call BufExplorer_ReSize()
        +  " put cursor on the next buffer
    else
        " skip to prev window if current buffer has a type
        " that is, its a special buffer 
        if &buftype !=? ''
            wincmd p
        endif
        " MRU list is faster than FZF History 
        MRU
    endif

    " Make repeated calls progress through the list
    setlocal cursorline
    nmap <buffer> <Tab>   :call MyCycleNextLine()<CR>
    nmap <buffer> <C-Tab> :call MyCycleNextLine()<CR>
    nmap <buffer> <\>     :call MyCycleNextLine()<CR>
    nmap <buffer> <C-\>   :call MyCycleNextLine()<CR>
    nmap <buffer> <Esc>   q
endfunction

command! -nargs=0 Switcher :call Switcher()

nnoremap <silent><C-Tab>        :Switcher<CR>
inoremap <silent><C-Tab>   <Esc>:Switcher<CR>
xnoremap <silent><C-Tab>   <Esc>:Switcher<CR>
nnoremap <silent><C-\>          :Switcher<CR>
inoremap <silent><C-\>     <Esc>:Switcher<CR>
xnoremap <silent><C-\>     <Esc>:Switcher<CR>

function! SafeNERDTreeFind()
    let l:pathStr = expand('%:p')
    if empty(l:pathStr)
        NERDTree
    else
        NERDTreeFind
    endif
endfunction

command! -nargs=0 SafeNERDTreeFind :call SafeNERDTreeFind()

" >> Leader Keys -----------------------------------------------------------{{{2

" This is my equivalent of a "no distractions" mode
" Note: Ctrl-L also does `nohlsearch`
noremap <silent><leader><space> :nohlsearch\|silent only<CR>

" > File short cuts
noremap <leader>? :edit ~/dotfiles/vim/cheatsheet.md<CR>
noremap <leader>N :NERDTree ~/Notes<CR>

" > Browsers
noremap <silent><leader>g :G<CR>
noremap <silent><leader><leader>G :Gbrowse<CR>
noremap <silent><leader>u :UndotreeToggle<CR>
noremap <silent><leader>n :SafeNERDTreeFind<CR>
noremap <silent><leader>a :Autoformat<CR>

" > vim-test
" \tt should override the plugin setting
" noremap <silent><leader>tt :TestNearest<CR>
noremap <silent><leader>tn :TestNearest<CR>
noremap <silent><leader>tn :TestFile<CR>
noremap <silent><leader>ts :TestSuite<CR>

" > FZF all use a \f prefix
noremap <silent><leader>fb :Buffers<CR>
noremap <silent><leader>ff :GFiles<CR>
noremap <silent><leader>fF :Files<CR>

noremap <silent><leader>fh :History<CR>
noremap <silent><leader>f: :History:<CR>
noremap <silent><leader>f/ :History/<CR>

noremap <silent><leader>ft :BTags<CR>
noremap <silent><leader>fT :Tags<CR>

noremap <silent><leader>fl :BLines<CR>
noremap <silent><leader>fL :Lines<CR>

noremap <silent><Leader>fm :Methods<CR>
noremap <silent><leader>fH :Helptags!<CR>
noremap <silent><leader>fM :Maps<CR>
noremap <silent><leader>fC :Commands<CR>
noremap <silent><leader>f' :Marks<CR>
noremap <silent><leader>fs :Filetypes<CR>

" > Grep all with a \v prefix (same bindings as easygrep) 
noremap <silent><leader>vv :grep! -w <cword><CR>
noremap <silent><leader>vV :grep! -w <cWORD><CR>
noremap <silent><leader>vf :grep! <cfile><CR>

" >> Fixes ------------------------------------------------------------------{{{2

" Tweaks to fix problematic mappings

" vim-checkbox sets a global mapping which should be buffer local
function FixTTMapping()
    " remap the to what I want it to be
    noremap <silent><leader>tt :TestNearest<CR>
    augroup vimterminal
        autocmd!
        autocmd BufEnter * 
            \   if &filetype ==# 'markdown'
            \ |     map <buffer><silent><leader>tt :call checkbox#ToggleCB()<cr>
            \ | endif
    augroup END
endfunction

autocmd! User vim-checkbox call FixTTMapping()

" Don't use Ex mode, use Q for formatting.
map Q gq

" The perl-support plugin uses mapleaders a lot and the default leader (\)
" conflicts with inputing references, so we make these explicit to terminate the
" lookup as soon as they are entered
inoremap <silent> <leader>$ \$
inoremap <silent> <leader>@ \@
inoremap <silent> <leader>% \%
inoremap <silent> <leader>& \&

" CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
" so that you can undo CTRL-U after inserting a line break.
" Revert with ":iunmap <C-U>".
inoremap <C-U> <C-G>u<C-U>

" Break undo sequence on specific characters
inoremap , ,<C-g>u
inoremap . .<C-g>u
inoremap ! !<C-g>u
inoremap ? ?<C-g>u

" FIXME do I need this anymore?
if &term =~? 'xterm.*'"
    " remap these from the terminal codes
    map <Esc>O1;2A <S-Up>
    map <Esc>O1;2B <S-Down>
    map <Esc>O1;2C <S-Right>
    map <Esc>O1;2D <S-Left>
    map <Esc>O1;3A <A-Up>
    map <Esc>O1;3B <A-Down>
    map <Esc>O1;3C <A-Right>
    map <Esc>O1;3D <A-Left>
    map <Esc>O1;5A <C-Up>
    map <Esc>O1;5B <C-Down>
    map <Esc>O1;5C <C-Right>
    map <Esc>O1;5D <C-Left>

    imap <Esc>O1;2A <S-Up>
    imap <Esc>O1;2B <S-Down>
    imap <Esc>O1;2C <S-Right>
    imap <Esc>O1;2D <S-Left>
    imap <Esc>O1;3A <A-Up>
    imap <Esc>O1;3B <A-Down>
    imap <Esc>O1;3C <A-Right>
    imap <Esc>O1;3D <A-Left>
    imap <Esc>O1;5A <C-Up>
    imap <Esc>O1;5B <C-Down>
    imap <Esc>O1;3C <A-Right>
    imap <Esc>O1;3D <A-Left>
    imap <Esc>O1;5A <C-Up>
    imap <Esc>O1;5B <C-Down>
    imap <Esc>O1;5C <C-Right>
    imap <Esc>O1;5D <C-Left>
endif
